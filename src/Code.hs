{-|
Description : provides a class for codes that represent atomic symbols that originate from bit codes in data streams 
    like character codes and other byte and bit sequences.
Copyright   : (c) Jörg K.-H. W. Brüggmann, 2021-2022
License     : proprietary, to be dual licensed
Maintainer  : info@joerg-brueggmann.de
Stability   : experimental
Portability : POSIX

The module Code provides the class 'Code', and its instances of atomic symbol representations 
    that may originate from bit codes in data streams like character codes and other byte and bit sequences.

The main purpose of class 'Code' is 

    * to validate internal representation of a code, and 
    * to normalise internal representation of a code, see 'isValid', 'cdNormalise', 'niOrd', 'cdFromInteger'.

The class 'Code' does not provide means to directly convert memory or data streams into such atomic symbols.
However, if the code is constructed from pieces of memory or pieces from data streams then the 'code' can be validated and/or normalised.
See also 'Octetable', 'OctetCodec', 'TypededCodeOctets' and 'FileSystem'.

In order to understand this documentation, please read the following definitions:

    * normalised: A code is normalised when the normalising function ('cdNormalise' maps from code to normalised code) leads to identical code.

        * A normalised code should be the safest, and smallest represetation, e.g. from 'CU8TwoBytes 0b11000001 0b10111101' to 'CU8OneByte 0x7D'.

    * not normalised: A code is not normalised when the normalising function ('cdNormalise') leads to different code.

        * Not normalised code can be normalised to a smaller represetation, e.g. from 'CU8TwoBytes 0b11000001 0b10111101' to 'CU8OneByte 0x7D'.

        <<media/Normalisation.png>>

    * valid: A code is valid when its instantiated code represents a character.

    * invalid: A code is invalid when the instantiated code does not represent a defined character and is subject to replacement ('cdReplacement') when normalising.

        <<media/ValidityAndNormalisation.png>>

    NUL: A code is NUL when it represent the neutral character, and does not print or changes positions, respectively.

Available instances of 'Code' are 

    * 'Char'            - the standard 'Prelude' character code (internal unicode representation), 
    * 'CharUtf8'        - to represent UTF-8 character code, 
    * 'CharIso1'        - to represent ISO 8859-1 character code, 
    * 'CharWin1'        - to represent Windows-1252 character code, 
    * 'Octets.Octet'    - to represent an 'Octets.Octet' as defined in module Octets, and 
    * 'Bool'            - to represent a bit.
-}

{-# LANGUAGE BinaryLiterals #-}
{-# LANGUAGE AllowAmbiguousTypes #-}
{-# LANGUAGE TypeSynonymInstances #-}

module Code
    (
        Code(..),
        CharUtf8(..), 
        CharIso1(..),
        CharWin1(..),
        Oct.Octet,
        T.Px(..)
    ) where

import qualified Type as T
import qualified Safer as Sfr
import qualified Octets as Oct

import qualified Data.Bits as Bts hiding ((.|.), (.&.))
import           Data.Bits ((.|.), (.&.))
import qualified Data.Char as Chr

--import Debug.Trace

-- class Code...
{-| ...class of atomic symbol representations.

Prefix: cd

Characteristics (What it does.)

    * An instantiated code ('cd') is a structure close to the structure in memory and stream, respectively.

        * e.g. 'CharUtf8' represents characters structured in one, two, three or four 'octets'

    * An instantiated code ('cd') may be valid or invalid ('isValid 'cd' == 'true').
    * A code ('cd') may be evaluated as NUL (e.g. ('isNul' ('CU8TwoBytes' 0xC0 0x80)) == 'true'; ('isNul' 'cdNul') == 'true').
    * Each instantiated code can be transformed into an 'Integer' number by 'niOrd'.
    * Each instantiated code has a defined replacement character ('cdReplacement'), e.g. '�' for Char.
    * An instantiated code can be normalised with 'cdNormalise', 

        * from an invalid character to 'cdReplacement', e.g. from 'CU8OneByte 0x81' to 'cdReplacement'.

    * Each normalised code can be generated by 'cdFromInteger'.
    * Default implementation of 'cdNormalise' is 'cdFromInteger' '.' 'niOrd'.
    * Each instantiated code can create a 'Char' from code by 'chFromCode'.
    * Default implementation of 'chFromCode' is 'chFromCode' 'cd' '=' '(' 'cdFromInteger' '(' 'niOrd' 'cd' ')' ')'.
    * A normalised code can be created from 'Char' by 'cdFromChar'.
    * Default implementation of 'cdFromChar' is 'cdFromChar' 'ch' '=' '(' 'cdFromInteger' '(' 'niOrd' 'ch' ')' ')'.

Laws (How it ist tested.)

    * Law #1: "Range" - Each instance of 'Code' has a defined range of ordinal numbers of normalised codes whereas its ordinal numbers start at niMinOrd and and end at (niMaxOrd)

        * "consecutive, gapless" - whereas the number of represented, normalised characters is 'niMaxOrd' '-' 'niMinOrd' '+' 1, 
        * "replacement outside range" - implying for all numbers ('ni') that are outside the range 'cdFromInteger' results in 'cdReplacement', 
        * "only one replacement in range" - implying for all numbers ('ni') that are inside the range for one and only one 'cdReplacement' 'ni' it results in 'cdReplacement', and 
        * implying for all numbers ('ni') that are inside the range result in unique codes.

    * Law #2: "NUL is tested NUL" - The expression "'isNul' 'cdNul'" results in 'true'.
    * Law #3: "NUL is normalised" - The code 'cdNul' is normalised (('cdNormalise' 'cdNul') '==' 'cdNul').
    * Law #4: "codes that are tested NUL are also tested NUL if normalised" - A code ('cd') is considered NUL ('isNul' 'cd' '==' 'true') even if the code is not normalised and if it\'s normalised code is NUL.

        * For all codes ('cd') where '(' 'isNull' '(' 'cdNormalise' 'cd' ')' ')' is 'true' there it also has to hold true '(' 'isNull' 'cd' ')' is 'true'.

    * Law #5: "ordinal number in range if valid"

        * For all codes ('cd') that are valid ('isValid' 'cd' '==' 'true') it's ordinal number is in the defined range of ordinal numbers 
        of normalised codes (('niOrd' 'cd') '>=' 'niMinOrd') && (('niOrd' 'cd') '<=' niMaxOrd).

    * Law #6: "ordinal number -1 if not valid"

        * For all codes ('cd') that are valid ('isValid' 'cd' '==' 'false') it's ordinal number is -1.

    * Law #7: "replacement is valid" - The expression "'isValid' 'cdReplacement'" results always in 'true'.
    * Law #8: "code that is NUL is valid" - If an instantiated code ('cd') is NUL ('isNul' 'cd' == true) then it is also valid ('isValid' 'cd' == true).

        * Implies: The expression "'isValid' 'cdNul'" results in 'true'.

    * Law #9: "always normalised code from integer" - The function 'cdFromInteger' creates always valid, normalised code.

        * whereas outside the range all codes become replacement character ('cdReplacement').

    * Law #10: "replacement is always normalised" - The code 'cdReplacement' is normalised (('cdNormalise' 'cdReplacement') '==' 'cdReplacement').

    * Law #11: "normalised code is equal normalised normalised code" - Normalisation of normalised code will always result into the same code ('cdNormalise' ('cdNormalise' 'cd')) '==' ('cdNormalise' 'cd').

        * Hence, ('cdNormalise' ('cdFromInteger' 'n')) '==' ('cdFromInteger' 'n'), whereas 'n' can be any number.

    * Law #12: "normalised code is always valid" - Normalised code is always valid (('isValid' 'cd' '==' 'true') for all 'cd' where ('cdNormalise' ('cdNormalise' 'cd')) '==' ('cdNormalise' 'cd')).
-}
class (Eq cd) => Code cd where
    -- cdNul
    -- | ...neutral element of the type of class 'Code'.
    cdNul :: cd
    -- isNul
    -- | ...whether the code is a neutral element.
    isNul :: cd -> Bool
    -- isValid
    -- | ...whether the code is valid.
    isValid :: cd -> Bool
    -- cdReplacement
    -- | ...replacement of the type of class 'Code', e.g. to replace invalid code.
    cdReplacement :: cd
    -- niOrd
    -- | ...ordinal number of the code normalised value or -1 if the code is invalid. 
    niOrd :: cd -> Integer
    -- cdFromInteger
    -- | ...code from the ordinal number or 'cdReplacement' if the first parameter (ordinal number, 'ni') is out of range. See also 'niMinOrd' and 'niMaxOrd'.
    cdFromInteger :: Integer -> cd
    -- niMinOrd
    -- | ...provides the lowest ordinal number, that is always 0 or greater.
    niMinOrd :: T.Px cd -> Integer
    niMinOrd _ = 0                                                              -- unit test in SpecCharCode.h - see instance Cd.Code Stub
    -- niMaxOrd
    -- | ...provides the largest ordinal number.
    niMaxOrd :: T.Px cd -> Integer
    -- cdNormalise
    -- | ...converts code to the normal form. Default implementation of 'cdNormalise': 'cdFromInteger' '.' 'niOrd'
    {-|
    * removes redundancies, and reduces code to the smallest size respectively
    * is neccessary, if the data type is larger than the needed space to represent the character set

        * e.g for CharUtf8 'CU8OneByte 0x7D' is the normalised version of 'CU8TwoBytes 0b11000001 0b10111101'

    * if parameter is '0' or greater then it provides the character code according to the ordinal number

        * otherwise it provides 'cdReplacement'
    -}
    cdNormalise :: cd -> cd
    cdNormalise = cdFromInteger . niOrd                                         -- unit test in SpecCharCode.h - see instance Cd.Code Stub
    -- isNormalised
    -- | ...detects whether the code is already in normal form or whether it would change when normalised by 'cdNormalise'.
    {-|
    * default implementation is 'cd' '==' '(' 'cdNormalise' 'cd' ')'
    -}
    isNormalised :: cd -> Bool
    isNormalised cd = cd == cdNormalise cd                                      -- unit test in SpecCharCode.h - see instance Cd.Code Stub
    -- chFromCode
    -- | ...character from code ('Code').
    chFromCode :: cd -> Char
    -- cdFromChar
    -- | ...code from character ('Code').
    cdFromChar :: Char -> cd

instance Code Char where
    -- cdNul :: cd
    cdNul = '\0'
    -- isNul :: cd -> Bool
    isNul cd = cd == cdNul
    -- isValid :: cd -> Bool
    isValid _ = True
    -- cdReplacement :: cd
    cdReplacement = '\xFFFD'                -- is U+FFFD, and hence'�'
    -- niOrd :: cd -> Integer
    niOrd ch = fromIntegral (Chr.ord ch)    -- provides a zero based ordinal number equal to the unicode code point
    -- cdFromInteger :: Integer -> cd 
    cdFromInteger ni                        -- converts the ordinal number to a character of type 'Char'
        | ni >= 0 && ni <= 0x10FFFF = Chr.chr (fromIntegral ni)
        | otherwise                 = cdReplacement
    -- niMaxOrd :: (T.Px cd) -> Integer
    niMaxOrd _ = 0x10FFFF
    -- cdNormalise :: cd -> cd
    cdNormalise = id
    -- chFromCode :: cd -> Char
    chFromCode = id
    -- cdFromChar :: Char -> cd
    cdFromChar = id

instance Sfr.Enum Char where
    -- toEnum              :: Integer -> a
    toEnum = cdFromInteger
    -- fromEnum            :: a -> Integer
    fromEnum = niOrd

-- CharUtf8...
-- | ISO 8859-1 character (latin-1)
{-|
Prefix: cu8

Characteristics

* represents an UTF-8 character
* keeps one, two, three or four octets
* keeps the octets as they are in an UTF-8 octet stream
* regarding particular functions

    * 'cdNul'

        * returns '(CU8OneByte 0x00)' which is U+0000, and hence '\0'

    * 'isValid'

        * returns boolean value to indicate whether the parameter is valid
        * it is considered valid if the binary formating plays by the rules

            * U+0000 to U+007F   -> Byte 1: 0xxxxxxx
            * ...    to U+07FF   -> Byte 1: 110xxxxx, Byte 2: 10xxxxxx
            * ...    to U+FFFF   -> Byte 1: 1110xxxx, Byte 2: 10xxxxxx, Byte 3: 10xxxxxx
            * ...    to U+10FFFF -> Byte 1: 11110xxx, Byte 2: 10xxxxxx, Byte 3: 10xxxxxx, Byte 4: 10xxxxxx

        * it is still considered valid when the code point is packed in more bytes than neccessary

            * e.g. (Cd.CU8ThreeBytes 0b11100000 0b10000000 0b10111111) is a valid char, and equals U+003F

    * 'cdReplacement'

        * returns '(CU8ThreeBytes 0xEF 0xBF 0xBD)' which is U+FFFD, and hence '�'
-}
data CharUtf8 =
      CU8OneByte Oct.Octet
    | CU8TwoBytes Oct.Octet Oct.Octet
    | CU8ThreeBytes Oct.Octet Oct.Octet Oct.Octet
    | CU8FourBytes Oct.Octet Oct.Octet Oct.Octet Oct.Octet
    deriving (Show, Eq, Ord)

instance Sfr.Enum CharUtf8 where
    -- toEnum              :: Integer -> a
    toEnum = cdFromInteger
    -- fromEnum            :: a -> Integer
    fromEnum = niOrd

instance Code CharUtf8 where
    -- cdNul :: cd
    cdNul = CU8OneByte 0x00
    -- isNul :: cd -> Bool
    isNul cd = niOrd cd == 0
    -- isValid _ = True
    isValid (CU8OneByte oct1) =
        oct1 < 0x80
    isValid (CU8TwoBytes oct1 oct2) =
        oct1 .&. 0b11100000 == 0b11000000 &&    -- 0b110xxxxx
        oct2 .&. 0b11000000 == 0b10000000       -- 0b10xxxxxx
    isValid (CU8ThreeBytes oct1 oct2 oct3) =
        oct1 .&. 0b11110000 == 0b11100000 &&    -- 0b1110xxxx
        oct2 .&. 0b11000000 == 0b10000000 &&    -- 0b10xxxxxx
        ((oct3 .&. 0b11000000) == 0b10000000)       -- 0b10xxxxxx
    isValid cu8@(CU8FourBytes oct1 oct2 oct3 oct4) =
        ((oct1 .&. 0b11111000) == 0b11110000) &&    -- 0b11110xxx
        ((oct2 .&. 0b11000000) == 0b10000000) &&    -- 0b10xxxxxx
        ((oct3 .&. 0b11000000) == 0b10000000) &&    -- 0b10xxxxxx
        ((oct4 .&. 0b11000000) == 0b10000000) &&    -- 0b10xxxxxx
        niOrdFromCU8' cu8 <= 0x10FFFF -- code points from U+10000 to U+10FFFF
    -- cdReplacement :: cd
    cdReplacement = CU8ThreeBytes 0xEF 0xBF 0xBD
    -- niOrd :: cd -> Integer
    niOrd cu8
        | isValid cu8   = niOrdFromCU8' cu8
        | otherwise     = -1
    -- cdFromInteger :: Integer -> cd
    cdFromInteger ni
        | (ni >=    0x00) && (ni <=     0x7F) =
            CU8OneByte (fromIntegral ni)                    -- 0<--7-->
        | (ni >=    0x80) && (ni <=   0x07FF) =
            let
                loct = loctFixFromInteger ni 2
                [oct1] = Oct.loctBitField (10, 6) loct   -- xxxxx<-5->xxxxxx
                [oct2] = Oct.loctBitField (5, 0) loct    -- xxxxxxxxxx<--6->
            in
                CU8TwoBytes (oct1 .|. 0b11000000) (oct2 .|. 0b10000000) -- 110<-5-> 10<--6->
        | (ni >=  0x0800) && (ni <=   0xFFFF) =
            let
                loct = loctFixFromInteger ni 2
                [oct1] = Oct.loctBitField (15, 12) loct  -- <-4>xxxxxxxxxxxx
                [oct2] = Oct.loctBitField (11, 6) loct   -- xxxx<--6->xxxxxx
                [oct3] = Oct.loctBitField (5, 0) loct    -- xxxxxxxxxx<--6->
            in
                CU8ThreeBytes (oct1 .|. 0b11100000) (oct2 .|. 0b10000000) (oct3 .|. 0b10000000) -- 1110<-4> 10<--6-> 10<--6->
        | (ni >= 0x10000) && (ni <= 0x10FFFF) =
            let
                loct = loctFixFromInteger ni 3
                [oct1] = Oct.loctBitField (20, 18) loct  -- xxx<3>xxxxxxxxxxxxxxxxxx
                [oct2] = Oct.loctBitField (17, 12) loct  -- xxxxxx<--6->xxxxxxxxxxxx
                [oct3] = Oct.loctBitField (11, 6) loct   -- xxxxxxxxxxxx<--6->xxxxxx
                [oct4] = Oct.loctBitField (5, 0) loct    -- xxxxxxxxxxxxxxxxxx<--6->
            in
                CU8FourBytes (oct1 .|. 0b11110000) (oct2 .|. 0b10000000) (oct3 .|. 0b10000000) (oct4 .|. 0b10000000) -- 11110<3> 10<--6-> 10<--6-> 10<--6->
        | otherwise =
            cdReplacement
        where
            loctFixFromInteger :: Integer -> Integer -> Oct.Octets
            loctFixFromInteger ni' niAmountOctets = Oct.loctFix niAmountOctets (Oct.loctFromIntegral ni')
    -- niMaxOrd :: (T.Px cd) -> Integer
    niMaxOrd _ = 0x10FFFF
    -- chFromCode :: cd -> Char
    chFromCode cd = cdFromInteger (niOrd cd)
    -- cdFromChar :: Char -> cd
    cdFromChar ch = cdFromInteger (niOrd ch)

-- niOrdFromCU8'
-- | ...computes the ordinal number - regardless of whether the leading bits are valid or not. 
niOrdFromCU8' :: CharUtf8 -> Integer
niOrdFromCU8' cu8@(CU8OneByte oct1) =
         fromIntegral (oct1 .&. 0b01111111)
niOrdFromCU8' cu8@(CU8TwoBytes oct1 oct2) =
        (fromIntegral (oct1 .&. 0b00011111) * 64) +
         fromIntegral (oct2 .&. 0b00111111)
niOrdFromCU8' cu8@(CU8ThreeBytes oct1 oct2 oct3) =
        (fromIntegral (oct1 .&. 0b00001111) * 4096) +
        (fromIntegral (oct2 .&. 0b00111111) * 64) +
         fromIntegral (oct3 .&. 0b00111111)
niOrdFromCU8' cu8@(CU8FourBytes oct1 oct2 oct3 oct4) =
        (fromIntegral (oct1 .&. 0b00001111) * 262144) +
        (fromIntegral (oct2 .&. 0b00111111) * 4096) +
        (fromIntegral (oct3 .&. 0b00111111) * 64) +
         fromIntegral (oct4 .&. 0b00111111)

-- CharIso1...
-- | ISO 8859-1 character (latin-1)
{-|
Prefix: ci1

Characteristics

* represents a ISO 8859-1 character

    * plus ASCII control signals from 0x00 - 0x1F, and 0x7F

* replacement code is U+003F, and hence just '?' (CharIso1 0x3F)
* keeps one octet
* regarding particular functions

    * 'cdNul'

        * returns '(CharIso1 0x00)'

    * 'isValid'

        * returns boolean value to indicate whether the parameter is valid
        * it is considered valid if the code is in one of the following ranges

            * 0x00 - 0x7F
            * 0xA0 - 0xFF

    * 'cdReplacement'

        * returns '(CharIso1 0x3F)' which is a question mark ('?')
-}
newtype CharIso1 = CharIso1 { roctCI1 :: Oct.Octet }
    deriving (Show, Eq, Ord)

instance Sfr.Enum CharIso1 where
    -- toEnum              :: Integer -> a
    toEnum = cdFromInteger
    -- fromEnum            :: a -> Integer
    fromEnum = niOrd

instance Code CharIso1 where
    -- cdNul :: cd
    cdNul = CharIso1 0x00
    -- isNul :: cd -> Bool
    isNul cd = niOrd cd == 0
    -- isValid :: cd -> Bool
    isValid (CharIso1 oct) = (oct < 0x80) || (oct >= 0xA0)
    -- cdReplacement :: cd
    cdReplacement = CharIso1 0x3F -- '?'
    -- niOrd :: cd -> Integer
    niOrd (CharIso1 oct)
      | oct < 0x80  = fromIntegral oct
      | oct >= 0xA0 = fromIntegral oct - 32
      | otherwise   = -1
    -- cdFromInteger :: Integer -> cd
    cdFromInteger ni
        | (ni >=   0) && (ni <= 127)    = CharIso1 (fromIntegral ni)
        | (ni >= 128) && (ni <= 223)    = CharIso1 (fromIntegral (ni + 32))
        | otherwise                     = cdReplacement
    -- niMaxOrd :: (T.Px cd) -> Integer
    niMaxOrd _ = 223
    -- chFromCode :: cd -> Char
    chFromCode (CharIso1 oct)
        | oct <= 0x7F = cdFromInteger (fromIntegral oct)
        | oct >= 0xA0 = cdFromInteger (fromIntegral oct)
        | otherwise   = cdReplacement
    -- cdFromChar :: Char -> cd
    cdFromChar ch
        | (ch >= '\x00') && (ch <= '\x7F')  = CharIso1 (fromIntegral (Chr.ord ch))
        | (ch >= '\xA0') && (ch <= '\xFF')  = CharIso1 (fromIntegral (Chr.ord ch))
        | otherwise  = cdReplacement

-- CharWin1...
-- | Windows-1252 character (commonly mislabeled as "ANSI"; also known as CP-1252, code page 1252)
{-|
Prefix: cw1

Characteristics

* represents a Windows-1252 character
* carries one octet
* regarding particular functions

    * 'cdNul'

        * returns '(CharWin1 0x00)'

    * 'isValid'

        * returns boolean value to indicate whether the parameter is valid
        * it is considered valid if the code is in one of the following ranges

            * 0x00 - 0x80
            * 0x82 - 0x8C
            * just 0x8E
            * 0x91 - 0x9C
            * 0x9E - 0xFF

    * 'cdReplacement'

        * returns '(CharWin1 0x3F)' which is a question mark ('?')
-}
newtype CharWin1 = CharWin1 { roctCW1 :: Oct.Octet }
    deriving (Show, Eq, Ord)

instance Sfr.Enum CharWin1 where
    -- toEnum              :: Integer -> a
    toEnum = cdFromInteger
    -- fromEnum            :: a -> Integer
    fromEnum = niOrd

instance Code CharWin1 where
    -- cdNul :: cd
    cdNul = CharWin1 0x00
    -- isNul :: cd -> Bool
    isNul cd = niOrd cd == 0
    -- isValid :: cd -> Bool
    isValid (CharWin1 oct) = (oct /= 0x81) && (oct /= 0x8D) && (oct /= 0x8F) && (oct /= 0x90) && (oct /= 0x9D)
    -- cdReplacement :: cd
    cdReplacement = CharWin1 0x3F -- '?'
    -- niOrd :: cd -> Integer
    niOrd ci1@(CharWin1 oct)
        | isValid ci1   =
            if oct <= 0x80
                then fromIntegral oct
                else (if oct <= 0x8C
                    then fromIntegral oct - 1
                    else (if oct <= 0x8E
                        then fromIntegral oct - 2
                        else (if oct <= 0x9C
                            then fromIntegral oct - 4
                            else fromIntegral oct - 5)))
        | otherwise     = -1
    -- cdFromInteger :: Integer -> cd
    cdFromInteger ni
        | (ni >=   0) && (ni <= 128)    = CharWin1 (fromIntegral ni)
        | (ni >= 129) && (ni <= 139)    = CharWin1 (fromIntegral (ni + 1))
        |  ni == 140                    = CharWin1 (fromIntegral (ni + 2))
        | (ni >= 141) && (ni <= 152)    = CharWin1 (fromIntegral (ni + 4))
        | (ni >= 153) && (ni <= 250)    = CharWin1 (fromIntegral (ni + 5))
        | otherwise                     = cdReplacement
    -- niMaxOrd :: (T.Px cd) -> Integer
    niMaxOrd _ = 250
    -- chFromCode :: cd -> Char
    chFromCode (CharWin1 oct)
        | oct <= 0x7F = cdFromInteger (fromIntegral oct)
        | oct == 0x80 = cdFromInteger 0x20AC -- €
        --        0x81
        | oct == 0x82 = cdFromInteger 0x201A -- ‚
        | oct == 0x83 = cdFromInteger 0x0192 -- ƒ
        | oct == 0x84 = cdFromInteger 0x201E -- „
        | oct == 0x85 = cdFromInteger 0x2026 -- …
        | oct == 0x86 = cdFromInteger 0x2020 -- †
        | oct == 0x87 = cdFromInteger 0x2021 -- ‡
        | oct == 0x88 = cdFromInteger 0x02C6 -- ˆ
        | oct == 0x89 = cdFromInteger 0x2030 -- ‰
        | oct == 0x8A = cdFromInteger 0x0160 -- Š
        | oct == 0x8B = cdFromInteger 0x2039 -- ‹
        | oct == 0x8C = cdFromInteger 0x0152 -- Œ
        --       0x8D
        | oct == 0x8E = cdFromInteger 0x017D -- Ž
        --       0x8F
        --       0x90
        | oct == 0x91 = cdFromInteger 0x2018 -- ‘
        | oct == 0x92 = cdFromInteger 0x2019 -- ’
        | oct == 0x93 = cdFromInteger 0x201C -- “
        | oct == 0x94 = cdFromInteger 0x201D -- ”
        | oct == 0x95 = cdFromInteger 0x2022 -- •
        | oct == 0x96 = cdFromInteger 0x2013 -- –
        | oct == 0x97 = cdFromInteger 0x2014 -- —
        | oct == 0x98 = cdFromInteger 0x02DC -- ˜
        | oct == 0x99 = cdFromInteger 0x2122 -- ™
        | oct == 0x9A = cdFromInteger 0x0161 -- š
        | oct == 0x9B = cdFromInteger 0x203A -- ›
        | oct == 0x9C = cdFromInteger 0x0153 -- œ
        --        0x9D
        | oct == 0x9E = cdFromInteger 0x017E -- ž
        | oct == 0x9F = cdFromInteger 0x0178 -- Ÿ
        | oct >= 0xA0 = cdFromInteger (fromIntegral oct)
        | otherwise     = cdReplacement
    -- cdFromChar :: Char -> cd
    cdFromChar ch
        | (ch >= '\x00') && (ch <= '\x7F')  = cdFromInteger (niOrd ch)
        | ch == '\x20AC' = CharWin1 0x80 -- €
        --                          0x81
        | ch == '\x201A' = CharWin1 0x82 -- ‚
        | ch == '\x0192' = CharWin1 0x83 -- ƒ
        | ch == '\x201E' = CharWin1 0x84 -- „
        | ch == '\x2026' = CharWin1 0x85 -- …
        | ch == '\x2020' = CharWin1 0x86 -- †
        | ch == '\x2021' = CharWin1 0x87 -- ‡
        | ch == '\x02C6' = CharWin1 0x88 -- ˆ
        | ch == '\x2030' = CharWin1 0x89 -- ‰
        | ch == '\x0160' = CharWin1 0x8A -- Š
        | ch == '\x2039' = CharWin1 0x8B -- ‹
        | ch == '\x0152' = CharWin1 0x8C -- Œ
        --                          0x8D
        | ch == '\x017D' = CharWin1 0x8E -- Ž
        --                          0x8F
        --                          0x90
        | ch == '\x2018' = CharWin1 0x91 -- ‘
        | ch == '\x2019' = CharWin1 0x92 -- ’
        | ch == '\x201C' = CharWin1 0x93 -- “
        | ch == '\x201D' = CharWin1 0x94 -- ”
        | ch == '\x2022' = CharWin1 0x95 -- •
        | ch == '\x2013' = CharWin1 0x96 -- –
        | ch == '\x2014' = CharWin1 0x97 -- —
        | ch == '\x02DC' = CharWin1 0x98 -- ˜
        | ch == '\x2122' = CharWin1 0x99 -- ™
        | ch == '\x0161' = CharWin1 0x9A -- š
        | ch == '\x203A' = CharWin1 0x9B -- ›
        | ch == '\x0153' = CharWin1 0x9C -- œ
        --                          0x9D
        | ch == '\x017E' = CharWin1 0x9E -- ž
        | ch == '\x0178' = CharWin1 0x9F -- Ÿ
        | (ch >= '\xA0') && (ch <= '\xFF') = CharWin1 (fromIntegral (Chr.ord ch))
        | otherwise  = cdReplacement

-- Oct.Octet...
-- | ...an 'Octet' as 'Code'.
{-|
Prefix: oct

Characteristics

* converts to characters compatible with code points

    * e.g. 0x00 translates to NUL
    * e.g. 0x20 translates to space (" ")
    * e.g. 0x41 converts to character "\A"
    * e.g. 0xA9 converts to character '©'

* regarding particular functions

    * 'cdNul'

        * returns 0x00, which translates to U+0000, and hence NUL
    
    * 'isNul'

        * is only true for 0x00

    * 'isValid'

        * is always true because all possible values (265) are valid

    * 'cdReplacement'

        * is 0xFF
-}
instance Code Oct.Octet where
    -- cdNul :: cd
    cdNul = 0x00
    -- isNul :: cd -> Bool
    isNul cd = niOrd cd == 0
    -- isValid :: cd -> Bool
    isValid _ = True
    -- cdReplacement :: cd
    cdReplacement = 0xFF
    -- niOrd :: cd -> Integer
    niOrd = fromIntegral
    -- cdFromInteger :: Integer -> cd
    cdFromInteger ni
        | (ni >= 0) && (ni <= 255)  = fromIntegral ni
        | otherwise                 = cdReplacement
    -- niMaxOrd :: (T.Px cd) -> Integer
    niMaxOrd _ = fromIntegral (0xFF :: Oct.Octet)
    cdNormalise = id
    -- chFromCode :: cd -> Char
    chFromCode oct  = cdFromInteger (fromIntegral oct) -- cdFromInteger implies :: Char
    -- cdFromChar :: Char -> cd
    cdFromChar ch 
        | niOrd <= 0xFF = fromIntegral niOrd
        | otherwise     = cdReplacement
        where
            niOrd = Chr.ord ch

instance Sfr.Enum Oct.Octet where
    -- toEnum              :: Integer -> a
    toEnum = cdFromInteger
    -- fromEnum            :: a -> Integer
    fromEnum = niOrd

-- Bool...
-- | ...is the usual boolean.
{-|
Prefix: is

Characteristics

* converts to the characters '0' and '1'

    * False translates '0'
    * True translates '1'

* regarding particular functions

    * 'cdNul'

        * returns False
    
    * 'isNul'

        * is only true for False

    * 'isValid'

        * is always true because both values are valid

    * 'cdReplacement'

        * is True
-}
instance Code Bool where
    -- cdNul :: cd
    cdNul = False
    -- isNul :: cd -> Bool
    isNul False = True
    isNul True = False
    -- isValid :: cd -> Bool
    isValid _ = True
    -- cdReplacement :: cd
    cdReplacement = True
    -- niOrd :: cd -> Integer
    niOrd False = 0
    niOrd True  = 1
    -- cdFromInteger :: Integer -> cd
    cdFromInteger 0 = False
    cdFromInteger 1 = True
    cdFromInteger _ = cdReplacement
    -- niMaxOrd :: (T.Px cd) -> Integer
    niMaxOrd _ = 1
    -- cdNormalise :: cd -> cd
    cdNormalise = id
    -- chFromCode :: cd -> Char
    chFromCode False    = '0'
    chFromCode True     = '1'
    -- cdFromChar :: Char -> cd
    cdFromChar '0'  = False
    cdFromChar '1'  = True
    cdFromChar _    = cdReplacement

instance Sfr.Enum Bool where
    -- toEnum              :: Integer -> a
    toEnum = cdFromInteger
    -- fromEnum            :: a -> Integer
    fromEnum = niOrd
